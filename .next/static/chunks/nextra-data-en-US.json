{"/guide/getting-started":{"title":"Getting Started with OmegaONE","data":{"":"OmegaONE was designed in a way, that setting it up and developing apps using it would be a piece of cake.\r\nGiven that Omega is a purely javascript framework, there are no need of compilers or any other transformers\r\nfor Omega.\nOmegaONE itself don't need a compiler to transform it to pure javascript, but if you are using libraries\r\nlike SCSS, then you'd need a compiler specific to that.","video-lecture#Video Lecture":"","installing-omegaone#Installing OmegaONE":"","1-modular-cdn#1. Modular CDN":"Installing OmegaONE is a piece of cake. You can directly use it in your HTML using our unique modular import\r\ncdn.\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n  <head>\r\n    <meta charset=\"UTF-8\" />\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\r\n    <title>Hello Omega</title>\r\n  </head>\r\n  <body>\r\n\r\n    <script type=\"importmap\">\r\n      {\r\n        \"imports\": {\r\n          \"@indivice/omega/\": \"https://indivice.github.io/omega/dist/\"\r\n        }\r\n      }\r\n    </script>\r\n\r\n    <div id=\"app\"></div>\r\n    <script type=\"module\">\r\n      import { Render } from '@indivice/omega/index.js';\r\n      import { Layout } from '@indivice/omega/components.js';\r\n\r\n      Render({\r\n        selector: '#app',\r\n        app: () => \r\n            Layout.Column({\r\n                child: \"Hello World\"\r\n            })\r\n      })\r\n\r\n    </script>\r\n  </body>\r\n</html>","2-using-vite#2. Using Vite":"Vite is a popular scaffolding tool to build production applications. You can use OmegaONE with Vite using the vanilla settings.\r\nOmegaONE is compatible with both javascript and typescript\n$ cd my-vite-project\r\nmy-vite-project~$ npm i @indivice/omega","3-using-templates#3. Using Templates":"OmegaONE has for now, two basic templates that you can use directly without the hassle of setting things up. We are working on\r\na CLI tool that would help you to customize your templates and tools. All the templates uses Vite under the hood.","javascript-template#Javascript Template":"$ npx degit https://github.com/indivice/omega/template/js my-project\r\n$ cd my-project\r\nmy-project~$ npm i","typescript-template#Typescript Template":"$ npx degit https://github.com/indivice/omega/template/ts my-project\r\n$ cd my-project\r\nmy-project~$ npm i","next-steps#Next steps":"This section is more like tutorial; it goes through maximum features in a order where learning is easier; I\r\ntry to keep the articles very simple, and small to help understand small chunks of concepts.The upcoming articles in this guide section assumes that you have created your project using Vite. Though, after\r\ncompleting this guide, you can implement the core knowledge to anywhere Omega runs."}},"/guide/building-layouts":{"title":"Building Layouts in OmegaONE","data":{"":"The main reason why UI libraries like Omega exists, is to make the process of constructing user-interfaces easier.\r\nThis is done, by creating a structure, called Layouts.We can build Layouts in OmegaJS using Components, which are isolated and re-usable code logic that helps to\r\nrender some content on the browser.In this article, we will discuss how we can make static layouts, covering several aspects of building UI, best practices,\r\nrecommendations, and design principles.","video-lecture#Video Lecture":"","components-in-omegaone#Components in OmegaONE":"Components in the context of web development space, means isolated logic that when changed, is changed\r\nglobally, requiring less efforts when updating certain parts of the interface.In OmegaONE, Layouts are made by composing these components. You can either create your own components from\r\nscratch, or directly use the built-ins.","creating-a-component#Creating a Component":"Let us create a simple hello world component\nimport { Render } from '@indivice/omega'\r\nimport { Layout } from '@indivice/omega/compoonents'\r\n\r\nfunction HelloWorld() {\r\n\r\n    return Layout.Column({\r\n        child: \"Hello World\"\r\n    })\r\n    \r\n}\r\n\r\nRender({\r\n    selector: \"#app\",\r\n    app: HelloWorld\r\n})\nThe HelloWorld() function is our component, which is returning a Layout.Column({}) Component, which is\r\none of the built-ins of OmegaONE. Almost every built-in component takes a child, or an array of children, except for few like Content.BreakLine({}) because\r\nit does not require children.The Render({}) function here takes your component structure, calls it internally, and puts in on the DOM that the user finally\r\ninteracts with. In any application, the Render function is only called once, and it is provided with the root Component, from\r\nwhich every other component starts.","accepting-children#Accepting children":"One best thing about OmegaONE is that, the components are pure javascript function, and by that, I mean anything that is\r\npossible using pure javascript, is possible with OmegaONE too.You can accept children in your own custom component, or any other property, however you might see fit. For example, I can\r\ncreate a custom greeting message instead of \"Hello World\"\nimport { Render } from '@indivice/omega'\r\nimport { Layout } from '@indivice/omega/compoonents'\r\n\r\nfunction HelloWorld(greeting: string) {\r\n\r\n    return Layout.Column({\r\n        child: greeting\r\n    })\r\n    \r\n}\r\n\r\nRender({\r\n    selector: \"#app\",\r\n    app: () => HelloWorld(\"Welcome, Mayukh\")\r\n})\nNow, instead of showing \"Hello World\", it will show \"Welcome, Mayukh\". Though it will not change the message\r\nbased on some user input yet; which we will learn in the reactive layouts part.Let us now try accepting another component, say a showcase function!\nimport { Render, Component } from '@indivice/omega'\r\nimport { Layout, Input } from '@indivice/omega/compoonents'\r\n\r\nfunction ShowCase(name: string, component: Component) {\r\n\r\n    return Layout.Column({\r\n        children: [\r\n            `This component was made by ${name}`,\r\n            component\r\n        ]\r\n    })\r\n    \r\n}\r\n\r\nRender({\r\n    selector: \"#app\",\r\n    app: () => ShowCase(\"Mayukh\", Input.Button({ child: \"I am a button!\" }))\r\n})\nThis will show the name of the person that made the component, as well as the component itself.","styling-our-component#Styling our Component":"There are various methods of styling based on how you are using OmegaONE.","1-vite-bundling#1. Vite-Bundling":"If you are using vite, you can simply create external stylesheets and import them directly!\nimport { Render, Component } from '@indivice/omega'\r\nimport { Layout, Input } from '@indivice/omega/compoonents'\r\nimport './style.css'\r\n\r\nfunction ShowCase(name: string, component: Component) {\r\n\r\n    return Layout.Column({\r\n        id: \"color-id\", /*Or we can use class*/ class: \"font\",\r\n        children: [\r\n            `This component was made by ${name}`,\r\n            component\r\n        ]\r\n    })\r\n    \r\n}\r\n\r\nRender({\r\n    selector: \"#app\",\r\n    app: () => ShowCase(\"Mayukh\", Input.Button({ child: \"I am a button!\" }))\r\n})\n#color-id {\r\n    color: \"red\"; /*Or any other styling of your choice*/\r\n}\r\n\r\n.font {\r\n    font-family: \"Manrope\"\r\n}","2-inline-styles#2. Inline Styles":"We can use inline styles inside all components that supports it. If I have to be honest, all UI Components supports\r\ninline styling, the rest are technically not UI Components, they are dynamic helpers or builders.Just like in HTML, we can use the style property to give styles to our code!\nimport { Render, Component } from '@indivice/omega'\r\nimport { Layout, Input } from '@indivice/omega/compoonents'\r\n\r\nfunction ShowCase(name: string, component: Component) {\r\n\r\n    return Layout.Column({\r\n\r\n        style: {\r\n            color: \"red\"\r\n        },\r\n\r\n        id: \"color-id\",\r\n        children: [\r\n            `This component was made by ${name}`,\r\n            component\r\n        ]\r\n    })\r\n    \r\n}\r\n\r\nRender({\r\n    selector: \"#app\",\r\n    app: () => ShowCase(\"Mayukh\", Input.Button({ child: \"I am a button!\" }))\r\n})\nThe names of the styling in the inline format is a bit different. For example, background-color for normal\r\ncss would be backgroundColor in the inline format, and this applies for all dash-separated style name in css.","listening-to-events#Listening to Events":"One of the most important aspects of building web applications, is to listen to events. This is because, interfaces\r\nworks on the basis of interaction, and events are the foundation of this component-interatction model. All interactions\r\nfrom a component is driven through events.In omega, we prefix a lowercase on before all events. For example, onclick, or oninput, and this applies for all\r\nthe available events in HTML. Click to see list of all UI events.\nimport { Render, Component } from '@indivice/omega'\r\nimport { Layout, Input } from '@indivice/omega/compoonents'\r\n\r\nfunction ShowCase(name: string, component: Component) {\r\n\r\n    return Layout.Column({\r\n\r\n        onclick() {\r\n            alert(\"I was clicked!\")\r\n        },\r\n\r\n        style: {\r\n            color: \"red\"\r\n        },\r\n\r\n        id: \"color-id\",\r\n        children: [\r\n            `This component was made by ${name}`,\r\n            component\r\n        ]\r\n    })\r\n    \r\n}\r\n\r\nRender({\r\n    selector: \"#app\",\r\n    app: () => ShowCase(\"Mayukh\", Input.Button({ child: \"I am a button!\" }))\r\n})","library-specific-properties#Library specific properties":"There are properties other than the ones provided by HTML. Here is the list of all the\r\ncustom properties for all components:\nreference -> Takes in a State<HTMLElement> and stores the current real-dom element in it.\r\nCan be used to directly refer to a real dom element.\nondestroy -> Is a library specific event that triggers when the specific component is removed from the\r\nDOM.\n__driver__ -> Is a metadata-based property, which is used by Omega's driver, and are useful for developing\r\ncustom components and custom renderers.\nWe will learn more about reference property in the Reactive Layouts article.","other-native-components#Other Native components":"Aside from the pre-existing components we just saw, there are other useful components, that are technically not\r\navailable in the web platform, but are implemented by Omega to make it more useful.\nLayout.Portal(): Helps in creating component outside the component tree. This component is useful when\r\nshowing overlays like modals or alerts, that needs to be at the top of every other components. The component\r\nwill be outside a component, but can still use the logic of that component\nLayout.HTML(): Helps in creating pure-html based content, that can also be dynamically updated. It takes\r\neither a raw string, or a dynamic callback function.\nWe will learn all of them in our upcoming article Reactive Layouts","next-steps#Next Steps":"In this article, we learned to create simple layouts, but real applications are almost always dynamic, and\r\nneeds UI changing based on user interactions, which is very much lacking here.We will learn everything about reactive layouts in the next article, and build upon it, and making progress\r\ntowards building a real application."}},"/about":{"title":"About","data":{"":"This is the about page! This page is shown on the navbar."}},"/":{"title":"Welcome to OmegaONE!","data":{"":"I am glad to see you here! I have written this documentation, keeping in my mind, that several developers,\nexperienced and novice, will come here to seek knowledge. OmegaJS, a project that I started to see how far\nI can push the limits of web, got it's first major version, OmegaONE.To be able to take full advantage of this documentation, I expect my readers to know about the following:\nJavascript and Typescript\nData Structures & Algorithms\nDocument Object Model\nBasics of HTML & CSS\nI hope you have a great time learning OmegaONE, and a greater time building apps with it."}},"/videos":{"title":"Video Lectures","data":{"":"All OmegaJS video lectures are well-organized in this section. They are in their own sub-sections\r\nwith the links to the youtube videos.","omegajs-guide-gallery#OmegaJS Guide Gallery":"Part 1 - Getting Started\nPart 2 - Making Layouts"}},"/guide/reactive-layouts":{"title":"Dynamic Layouts in OmegaONE","data":{"":"So far, we learned about building simple and static layouts, but that is not enough to make real applications,\r\nsince real applications is reactive; it listens to changes, and is capable of updating the interface based\r\non some background activity or user interaction.We will build up our concepts by first understanding the reactive primitives, and best practices around\r\nreactive layouts.","video-lecture#Video Lecture":"","application-state#Application State":"Application state can be thought of a value, that describes the state of certain part of user-interface. For example,\r\nI can think of a game, whose score is a state, that might change based on how the player is performing.\r\nThere are several parts of UI that change, which ultimately depends upon some external variable or factor.We can implement such a state in Omega, using the State class.\nimport { State } from '@indivice/omega'\r\n\r\n//creates a state with 0 initial value\r\nconst counter = new State(0)\r\nexport counter\nThis counter, can now be used anywhere in your application, and changing the value of the counter, will change\r\nit everywhere the value is being consumed.It is not necessary to define a state in a service. Infact, states can be created and exported anywhere, as long\r\nas the state names are not conflicted.","state-operators#State operators":"Now that we have defined our state, we need a way to work with it. Since a state is a class, you will have object\r\nmethods, and static methods that helps in various operations","1-reading-and-writing#1. Reading and Writing":"We can read the current value of a state, using the .get() method, and we can set a new value of the state\r\nusing the .set() method.The reason why we do not directly mutate the values, is because there are additional functionality than just setting\r\nthe value that runs in the background, which actually makes the state reactive.Let us see a simple example using the counter state we defined previously.\nimport { counter } from './service/counter.service'\r\n\r\n//we will get 0 initially\r\nconsole.log(\r\n    counter.get()\r\n)\r\n\r\ncounter.set(1)\r\n\r\n//we will now get 1\r\nconsole.log(\r\n    counter.get()\r\n)\nAnother method that changes the value of the state is '.update()' method. The .update() method works differently\r\nbecause it takes a callback, that must return the value we intend on setting, and it also gives you the current\r\nvalue as the callback argument.Let us see an example of why it is useful:\nimport { counter } from './service/counter.service'\r\n\r\nsetInterval(() => {\r\n\r\n    counter.set( counter.get() + 1 )\r\n    console.log(\r\n        counter.get()\r\n    )\r\n\r\n}, 1000)\nWe can see in the highlighted portion, that the counter actually needs to increment it, because we cannot make assumptions\r\nabout the previous value. If you run this, it will simply logs number counting from 0 every 1 second.While this is not necessarily bad, it becomes highly complex when dealing with arrays, objects or other nested components,\r\nwhich when becomes a burden to handle. We can write a cleaner version using .update() method:\nimport { counter } from './service/counter.service'\r\n\r\nsetInterval(() => {\r\n\r\n    counter.update( prev => prev + 1 )\r\n    console.log(\r\n        counter.get()\r\n    )\r\n\r\n}, 1000)","2-subscription-and-batching#2. Subscription and Batching":"Now that we are capable of creating a state, changing it's value, or updating it, we might also need to\r\nlisten to changes too, and the type of change that happened.All reactivity in Omega is actually implemented on top of the Subscription method, since reactivity means\r\nchange detection, and reactive layouts will need to know when the state is changing.We can listen to changes using the .listen() method. A callback is provided to that method, and whenever the\r\nstate is changed, all the callbacks that are subscribed to that state are called one by one.Let us re-implement our counter using this:\nimport { counter } from './service/counter.service'\r\n\r\ncounter.listen(() => {\r\n    console.log(counter.get())\r\n})\r\n\r\nsetInterval(() => {\r\n    counter.update( prev => prev + 1 )\r\n}, 1000)\nThis will have the same effect as manually loggin it, but it is more powerful, because if the state were\r\nto update from anywhere else, this callback will still be executed!The subscriber is actually a Set, so you can remove a subscriber if you happen to know the reference.\r\nYou can actually get the reference, since it is returned by the listen method.\n//example code below\r\nconst state = new State(\"Hello World!\")\r\nconst callback = state.listen(() => console.log(state.get()))\r\n\r\n//something happened, I want to remove the listener\r\nstate.subscribers.delete(callback)\nWhile it seems very powerful that we can play around states unlike other frameworks/libraries,\r\nbut there are certain things you need to be aware of:\nChanging the value directly (which you can) will cause any of the subscribers to be NOT called,\r\nhence causing a hidden-change, which means changes that goes un-detected.\nThe .delete() method on the .subscribers member of the state can be played around too, but\r\nbe careful! because there are also other subscribers that might be listening to it! You do not want\r\nto have unexpected behaviours, unless ofcourse you know what you are doing.\nWhile all of this, we can also observe one problem, Repetion. Let me clarify by an example:\nimport { State } from '@indivice/omega'\r\n\r\nconst firstName = new State(\"Mayukh\")\r\nconst lastName = new State(\"Chakraborty\")\r\n\r\nconst callback = firstName.listen(() => {\r\n    console.log(`Full name: ${ firstName.get() } ${ lastName.get() }`)\r\n})\r\n\r\nlastName.listen(callback)\r\n\r\nfirstName.set(\"David\")\r\nlastName.set(\"Jones\")\nThe issue here is, when I am concurrently updating two states (i.e one after another), The function\r\nis called twice.Though this will not take a toll on your performance, but imagine you had to update\r\na lot of states at once, all of them have a common subscriber. That subscriber will be called that\r\nmany times, and only the last call will be useful (because all updates will be finished.)This is where the concpet of Batching comes into play.\nimport { State } from '@indivice/omega'\r\n\r\nconst firstName = new State(\"Mayukh\")\r\nconst lastName = new State(\"Chakraborty\")\r\n\r\nconst callback = firstName.listen(() => {\r\n    console.log(`Full name: ${ firstName.get() } ${ lastName.get() }`)\r\n})\r\n\r\nlastName.listen(callback)\r\n\r\nState.batch( //static function to batch update\r\n    firstName.set(\"David\", true) //set batching to true\r\n    lastName.set(\"Jones\", true) //sets batching to true\r\n)\nNow you'd see that the callback is called once, after all the values are updated.\nMake sure you are listening to the same functions while batching!","hook-functions#Hook functions":"Hooks in omega are just simple functions that starts with the prefix use. Hooks can be used\r\nanywhere, and can operate on anything.Hooks in omega are simply helper functions that helps the developer to abstract away messy code\r\nthat would otherwise affect readibilty, with no effect on performance, rather hooks might even improve\r\nperformance by doing things the right way.There are several built-in hooks in omega that looks after different aspects of your app, and we will\r\nlook into them one by one.","the-usememo-hook#The useMemo() Hook":"The useMemo() hook helps us to derive values from other states, and then tracks the changes of the\r\nsaid states. When any one of the state changes, the callback passed into the hook is called to re-build\r\nthe new value."}}}